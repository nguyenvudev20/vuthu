<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VĂN VŨ & ANH THƯ </title>
  <link rel="icon"
  href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%E2%9D%A4%EF%B8%8F%3C/text%3E%3C/svg%3E">

  <style>
    html, body { height: 100%; margin: 0; background: #fff; }
    body { display: grid; place-items: center; overflow: hidden; cursor: none; }

    /* Frame để tránh rìa ảnh khi animate */
    .frame { width: 90vw; height: 90vh;margin: 0px auto; inset: 0; overflow: hidden; display: grid; place-items: center; }
    .frame img { width: 90vw; height: 90vh;margin: 0px auto; object-fit: contain; display: block; backface-visibility: hidden; will-change: transform, opacity; }

    /* Overlay nhắc bật âm thanh (không có nút, chỉ click bất kỳ) */
    #overlay { position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,.7); color: #fff; font: 600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial; letter-spacing: .2px; }
    #overlay .card { padding: 16px 22px; border: 1px solid rgba(255,255,255,.2); border-radius: 12px; background: rgba(15,15,20,.6); }

    /* === Hiệu ứng (5 kiểu) === */
    .fx-fade   { animation: fade 7s ease-in-out infinite; }
    .fx-zoom-in  { animation: zoomIn 7s ease-in-out infinite; }
    .fx-zoom-out { animation: zoomOut 7s ease-in-out infinite; }
    .fx-pan-left { animation: panLeft 7s ease-in-out infinite; }
    .fx-pan-right{ animation: panRight 7s ease-in-out infinite; }

    @keyframes fade { 0%{opacity:.0} 10%{opacity:1} 90%{opacity:1} 100%{opacity:.0} }
    @keyframes zoomIn { 0%{transform:scale(1)} 100%{transform:scale(1.1)} }
    @keyframes zoomOut{ 0%{transform:scale(1.1)} 100%{transform:scale(1)} }
    @keyframes panLeft{ 0%{transform:translateX(3%) } 100%{transform:translateX(-3%)} }
    @keyframes panRight{0%{transform:translateX(-3%)} 100%{transform:translateX(3%) } }
  </style>
</head>
<body>
  <!-- Chỉ hiển thị duy nhất ảnh 1.jpg, full screen (không crop) -->
  <div class="frame"><img id="photo" src="hinhanh/1.jpg" alt="Slideshow" /></div>

  <!-- Nhạc nền mặc định (tự động thử phát) -->
  <audio id="bgm" src="audio/xứng đôi cưới thôi nhen.mp3" preload="auto" loop></audio>

  <!-- Overlay yêu cầu người dùng click để bật âm thanh nếu bị chặn autoplay -->
  <div id="overlay"><div class="card">Chạm bất kỳ để phát nhạc nền…</div></div>
<!-- FIREWORKS (pháo hoa giấy) -->
<canvas id="fx-canvas" aria-hidden="true"></canvas>

<style>
  /* Canvas phủ toàn màn hình, trên ảnh nhưng dưới overlay thông báo */
  #fx-canvas {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 5;
    display: block;
  }
</style>

<script>
  (function(){
    const canvas = document.getElementById('fx-canvas');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, DPR = Math.max(1, window.devicePixelRatio || 1);
    function resize(){
      W = window.innerWidth; H = window.innerHeight;
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // particle definition: small rotated rectangles (paper confetti)
    class Particle {
      constructor(x,y,angle,spread,color,size,life){
        const speed = (Math.random()*0.8 + 0.8) * (1 + spread*0.5);
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.size = size * (0.7 + Math.random()*0.6);
        this.w = this.size * (0.6 + Math.random()*0.8);
        this.h = this.size * (0.6 + Math.random()*0.8);
        this.rot = Math.random()*Math.PI*2;
        this.rotSpeed = (Math.random()-0.5) * 0.3;
        this.color = color;
        this.life = life;
        this.age = 0;
        this.gravity = 0.02 + Math.random()*0.04;
        this.drag = 0.995;
      }
      update(dt){
        this.age += dt;
        this.vx *= this.drag;
        this.vy += this.gravity * dt * 60;
        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.rot += this.rotSpeed * dt * 60;
      }
      draw(ctx){
        const t = Math.min(1, this.age / this.life);
        const alpha = 1 - t;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rot);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
        ctx.restore();
      }
      isDead(){ return this.age >= this.life || this.y - this.h > H + 50; }
    }

    const colors = [
      '#ff5d5d','#ffd166','#6ee7b7','#60a5fa','#c084fc',
      '#ffb4a2','#f7b267','#99ddcc','#7dd3fc','#e879f9'
    ];

    let particles = [];

    // spawn a "burst" like a paper firework at x,y
    function burst(x,y, count = 40, spread = 1.2, speed = 1){
      for(let i=0;i<count;i++){
        const angle = (Math.random()*Math.PI*2);
        const color = colors[Math.floor(Math.random()*colors.length)];
        const size = 6 + Math.random()*8;
        const life = 1.6 + Math.random()*1.6; // seconds
        particles.push(new Particle(x, y, angle, spread*speed, color, size, life));
      }
    }

    // periodic automatic bursts (like fireworks)
    let lastAuto = 0;
    function maybeAutoSpawn(time){
      if(time - lastAuto > 800 + Math.random()*1400){
        lastAuto = time;
        // spawn from near lower center upward arc for effect
        const x = (0.25 + Math.random()*0.5) * W;
        const y = (0.18 + Math.random()*0.12) * H;
        burst(x, y, 36 + Math.floor(Math.random()*28), 1.6, 1.2);
      }
    }

    // spawn burst on user pointer (optional)
    window.addEventListener('pointerdown', (e)=>{
      burst(e.clientX, e.clientY, 28, 1.8, 1.2);
    });

    // animation loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.06, (now - last) / 1000);
      last = now;

      // auto spawn occasionally
      maybeAutoSpawn(now);

      // update
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.update(dt);
        if(p.isDead()) particles.splice(i,1);
      }

      // draw
      ctx.clearRect(0,0,W,H);
      for(const p of particles) p.draw(ctx);

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // small helper: celebrate when music starts (if autoplay succeeded)
    const audio = document.getElementById('bgm');
    if(audio){
      audio.addEventListener('play', ()=> {
        // quick multi-burst celebration
        const cx = W/2, cy = H*0.22;
        for(let k=0;k<3;k++){
          setTimeout(()=> burst(cx + (Math.random()-0.5)*200, cy + (Math.random()-0.5)*60, 50, 2, 1.4), k*220);
        }
      }, {once:true});
    }

  })();
</script>

  <script>
    (async function(){
      const audio = document.getElementById('bgm');
      const overlay = document.getElementById('overlay');
      const img = document.getElementById('photo');

      // Thử autoplay có tiếng; nếu bị chặn, hiện overlay và phát khi user tương tác
      try { await audio.play(); }
      catch (_) {
        overlay.style.display = 'grid';
        const enable = async () => {
          overlay.style.display = 'none';
          try { audio.muted = false; await audio.play(); } catch (e) {}
          window.removeEventListener('pointerdown', enable);
          window.removeEventListener('keydown', enable);
        };
        window.addEventListener('pointerdown', enable, { once: true });
        window.addEventListener('keydown', enable, { once: true });
      }

      // Ẩn con trỏ sau 2s không hoạt động để trải nghiệm sạch sẽ
      let hideTimer; const hide = ()=> document.body.style.cursor='none';
      const show = ()=>{ document.body.style.cursor='auto'; clearTimeout(hideTimer); hideTimer=setTimeout(hide, 2000); };
      window.addEventListener('mousemove', show);
      hideTimer=setTimeout(hide, 2000);

      // ===== Thêm 5 hiệu ứng cho chính ảnh đó (luân phiên) =====
      // Danh sách class hiệu ứng. Có thể xáo trộn nếu muốn ngẫu nhiên.
      const effects = ['fx-fade','fx-zoom-in','fx-zoom-out','fx-pan-left','fx-pan-right'];
      let i = 0;
      function applyEffect(){
        img.className = ''; // xoá class cũ
        img.offsetHeight;   // force reflow để restart animation
        img.classList.add(effects[i % effects.length]);
        i++;
      }
      // Áp dụng ngay và lặp mỗi 7 giây
      applyEffect();
      setInterval(applyEffect, 7000);

      // Nếu ảnh đang bị "zoom/crop" ở bản trước do object-fit: cover,
      // mình đã đổi sang object-fit: contain ở CSS để **không cắt ảnh** nữa.
    })();
  </script>
</body>
</html>
